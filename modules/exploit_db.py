#!/usr/bin/env python3
"""
ExploitDB Integration Module for BugHunter Pro
Downloads and parses ExploitDB data from official CSV file
"""

import requests
import sqlite3
import csv
import logging
import time
from typing import List, Dict, Optional, Any
from datetime import datetime
from io import StringIO
from pathlib import Path

logger = logging.getLogger(__name__)


class ExploitDBSync:
    """ExploitDB synchronization and management"""
    
    # Official ExploitDB CSV from GitLab mirror
    EXPLOITDB_CSV_URL = "https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv"
    
    def __init__(self, database_path: str = "database/cve_database.db"):
        """
        Initialize ExploitDB Sync
        
        Args:
            database_path: Path to SQLite database
        """
        self.database_path = database_path
        self._ensure_database()
        
        logger.info("ExploitDB Sync initialized")
    
    def _ensure_database(self):
        """Ensure database exists"""
        db_path = Path(self.database_path)
        db_path.parent.mkdir(parents=True, exist_ok=True)
    
    def download_exploitdb_csv(self) -> Optional[str]:
        """
        Download ExploitDB CSV file
        
        Returns:
            CSV content as string or None
        """
        logger.info(f"Downloading ExploitDB CSV from {self.EXPLOITDB_CSV_URL}")
        
        try:
            response = requests.get(self.EXPLOITDB_CSV_URL, timeout=60)
            
            if response.status_code == 200:
                logger.info(f"‚úÖ Downloaded ExploitDB CSV ({len(response.text)} bytes)")
                return response.text
            else:
                logger.error(f"Failed to download: HTTP {response.status_code}")
                return None
        
        except requests.exceptions.RequestException as e:
            logger.error(f"Download failed: {e}")
            return None
    
    def parse_exploitdb_csv(self, csv_content: str) -> List[Dict[str, Any]]:
        """
        Parse ExploitDB CSV content
        
        Args:
            csv_content: CSV file content
        
        Returns:
            List of exploit records
        """
        exploits = []
        
        try:
            csv_reader = csv.DictReader(StringIO(csv_content))
            
            for row in csv_reader:
                try:
                    # Extract CVE IDs from codes field
                    cve_id = None
                    codes = row.get('codes', '')
                    if codes:
                        # CVE IDs are in the codes field
                        for code in codes.split(';'):
                            code = code.strip()
                            if code.startswith('CVE-'):
                                cve_id = code
                                break
                    
                    exploit = {
                        'exploit_id': f"EDB-{row.get('id', '')}",
                        'cve_id': cve_id,
                        'title': row.get('description', ''),
                        'author': row.get('author', ''),
                        'type': row.get('type', ''),
                        'platform': row.get('platform', ''),
                        'exploit_date': row.get('date', ''),
                        'verified': 1 if row.get('verified', '0') == '1' else 0,
                        'source': 'exploitdb',
                        'source_url': f"https://www.exploit-db.com/exploits/{row.get('id', '')}",
                        'tags': row.get('tags', '')
                    }
                    
                    exploits.append(exploit)
                
                except Exception as e:
                    logger.debug(f"Failed to parse row: {e}")
                    continue
            
            logger.info(f"Parsed {len(exploits)} exploits from CSV")
            return exploits
        
        except Exception as e:
            logger.error(f"Failed to parse CSV: {e}")
            return []
    
    def store_exploit(self, exploit: Dict[str, Any]) -> bool:
        """
        Store exploit in database
        
        Args:
            exploit: Exploit dictionary
        
        Returns:
            True if successful
        """
        try:
            conn = sqlite3.connect(self.database_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT OR REPLACE INTO exploits (
                    exploit_id, cve_id, title, author, type, platform,
                    exploit_date, verified, source, source_url, tags,
                    updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
            ''', (
                exploit['exploit_id'],
                exploit['cve_id'],
                exploit['title'],
                exploit['author'],
                exploit['type'],
                exploit['platform'],
                exploit['exploit_date'],
                exploit['verified'],
                exploit['source'],
                exploit['source_url'],
                exploit['tags']
            ))
            
            # Mark CVE as having exploit if CVE exists
            if exploit['cve_id']:
                cursor.execute('''
                    UPDATE cves
                    SET exploit_available = 1
                    WHERE cve_id = ?
                ''', (exploit['cve_id'],))
            
            conn.commit()
            conn.close()
            
            return True
        
        except Exception as e:
            logger.debug(f"Failed to store exploit {exploit['exploit_id']}: {e}")
            return False
    
    def sync_exploitdb(self, batch_size: int = 100) -> Dict[str, Any]:
        """
        Sync ExploitDB data
        
        Args:
            batch_size: Number of exploits to commit at once
        
        Returns:
            Sync result dictionary
        """
        logger.info("Starting ExploitDB synchronization")
        start_time = time.time()
        
        # Download CSV
        csv_content = self.download_exploitdb_csv()
        if not csv_content:
            return {
                'status': 'failed',
                'error': 'Failed to download CSV',
                'duration': time.time() - start_time
            }
        
        # Parse exploits
        exploits = self.parse_exploitdb_csv(csv_content)
        if not exploits:
            return {
                'status': 'failed',
                'error': 'No exploits parsed',
                'duration': time.time() - start_time
            }
        
        # Store exploits
        stored_count = 0
        failed_count = 0
        
        logger.info(f"Storing {len(exploits)} exploits...")
        
        for i, exploit in enumerate(exploits):
            if self.store_exploit(exploit):
                stored_count += 1
            else:
                failed_count += 1
            
            # Progress update
            if (i + 1) % batch_size == 0:
                logger.info(f"  Progress: {i + 1}/{len(exploits)} ({stored_count} stored, {failed_count} failed)")
        
        duration = time.time() - start_time
        
        # Update sync metadata
        self._update_sync_metadata(
            status='success' if failed_count == 0 else 'partial',
            records_synced=stored_count,
            records_failed=failed_count,
            duration=duration
        )
        
        logger.info(f"‚úÖ ExploitDB sync completed: {stored_count} stored, {failed_count} failed in {duration:.2f}s")
        
        return {
            'status': 'success',
            'total': len(exploits),
            'stored': stored_count,
            'failed': failed_count,
            'duration': duration
        }
    
    def _update_sync_metadata(
        self,
        status: str,
        records_synced: int = 0,
        records_failed: int = 0,
        duration: float = 0.0,
        error_message: Optional[str] = None
    ):
        """Update sync metadata in database"""
        try:
            conn = sqlite3.connect(self.database_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT OR REPLACE INTO sync_metadata (
                    source, last_sync_time, last_sync_status,
                    records_synced, records_updated, records_failed,
                    sync_duration, error_message, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
            ''', (
                'exploitdb',
                datetime.utcnow().isoformat(),
                status,
                records_synced,
                records_synced,
                records_failed,
                duration,
                error_message
            ))
            
            conn.commit()
            conn.close()
        
        except Exception as e:
            logger.error(f"Failed to update sync metadata: {e}")
    
    def search_exploits(
        self,
        cve_id: Optional[str] = None,
        keyword: Optional[str] = None,
        platform: Optional[str] = None,
        verified_only: bool = False,
        limit: int = 100
    ) -> List[Dict[str, Any]]:
        """
        Search exploits in database
        
        Args:
            cve_id: Filter by CVE ID
            keyword: Search in title
            platform: Filter by platform
            verified_only: Only verified exploits
            limit: Maximum results
        
        Returns:
            List of exploit records
        """
        try:
            conn = sqlite3.connect(self.database_path)
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            query = "SELECT * FROM exploits WHERE 1=1"
            params = []
            
            if cve_id:
                query += " AND cve_id = ?"
                params.append(cve_id)
            
            if keyword:
                query += " AND title LIKE ?"
                params.append(f"%{keyword}%")
            
            if platform:
                query += " AND platform = ?"
                params.append(platform)
            
            if verified_only:
                query += " AND verified = 1"
            
            query += " ORDER BY exploit_date DESC LIMIT ?"
            params.append(limit)
            
            cursor.execute(query, params)
            results = [dict(row) for row in cursor.fetchall()]
            
            conn.close()
            return results
        
        except Exception as e:
            logger.error(f"Failed to search exploits: {e}")
            return []
    
    def get_exploit_stats(self) -> Dict[str, Any]:
        """Get exploit database statistics"""
        try:
            conn = sqlite3.connect(self.database_path)
            cursor = conn.cursor()
            
            stats = {}
            
            # Total exploits
            cursor.execute("SELECT COUNT(*) FROM exploits")
            stats['total_exploits'] = cursor.fetchone()[0]
            
            # Verified exploits
            cursor.execute("SELECT COUNT(*) FROM exploits WHERE verified = 1")
            stats['verified_exploits'] = cursor.fetchone()[0]
            
            # With CVE
            cursor.execute("SELECT COUNT(*) FROM exploits WHERE cve_id IS NOT NULL")
            stats['with_cve'] = cursor.fetchone()[0]
            
            # By platform
            cursor.execute("""
                SELECT platform, COUNT(*) 
                FROM exploits 
                GROUP BY platform
                ORDER BY COUNT(*) DESC
                LIMIT 10
            """)
            stats['top_platforms'] = dict(cursor.fetchall())
            
            # By type
            cursor.execute("""
                SELECT type, COUNT(*) 
                FROM exploits 
                GROUP BY type
                ORDER BY COUNT(*) DESC
                LIMIT 10
            """)
            stats['top_types'] = dict(cursor.fetchall())
            
            conn.close()
            return stats
        
        except Exception as e:
            logger.error(f"Failed to get stats: {e}")
            return {}


if __name__ == "__main__":
    # Example usage
    logging.basicConfig(level=logging.INFO)
    
    print("\n" + "="*70)
    print("ExploitDB Integration Demo")
    print("="*70)
    
    # Initialize
    exploit_db = ExploitDBSync()
    
    # Sync ExploitDB (this will take a while - full database)
    print("\nüì• Syncing ExploitDB (this may take a few minutes)...")
    print("‚ö†Ô∏è  Note: This downloads the full ExploitDB database\n")
    
    result = exploit_db.sync_exploitdb(batch_size=500)
    
    print(f"\nSync Result:")
    print(f"  Status: {result['status']}")
    print(f"  Total: {result.get('total', 0)}")
    print(f"  Stored: {result.get('stored', 0)}")
    print(f"  Failed: {result.get('failed', 0)}")
    print(f"  Duration: {result['duration']:.2f}s")
    
    # Get stats
    print("\nüìä Exploit Database Statistics:")
    stats = exploit_db.get_exploit_stats()
    print(f"  Total Exploits: {stats.get('total_exploits', 0)}")
    print(f"  Verified: {stats.get('verified_exploits', 0)}")
    print(f"  With CVE: {stats.get('with_cve', 0)}")
    
    print(f"\n  Top Platforms:")
    for platform, count in list(stats.get('top_platforms', {}).items())[:5]:
        print(f"    {platform}: {count}")
    
    print(f"\n  Top Types:")
    for exploit_type, count in list(stats.get('top_types', {}).items())[:5]:
        print(f"    {exploit_type}: {count}")
    
    # Search example
    print("\nüîç Searching for 'SQL injection' exploits...")
    results = exploit_db.search_exploits(keyword="SQL injection", limit=5)
    
    print(f"\nFound {len(results)} results:")
    for exploit in results[:3]:
        print(f"\n  ID: {exploit['exploit_id']}")
        print(f"  Title: {exploit['title'][:60]}...")
        print(f"  Platform: {exploit['platform']}")
        print(f"  CVE: {exploit['cve_id'] or 'N/A'}")
        print(f"  URL: {exploit['source_url']}")
